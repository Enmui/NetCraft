diff --git a/src/library_glfw.js b/src/library_glfw.js
index dfa4896c4..6d42a4a4b 100644
--- a/src/library_glfw.js
+++ b/src/library_glfw.js
@@ -13,7 +13,6 @@
  * What it does not but should probably do:
  * - Transmit events when glfwPollEvents, glfwWaitEvents or glfwSwapBuffers is
  *    called. Events callbacks are called as soon as event are received.
- * - Joystick support.
  * - Input modes.
  * - Gamma ramps.
  * - Video modes.
@@ -57,6 +56,7 @@ var LibraryGLFW = {
       };
       this.buttons = 0;
       this.keys = new Array();
+      this.domKeys = new Array();
       this.shouldClose = 0;
       this.title = null;
       this.windowPosFunc = null; // GLFWwindowposfun
@@ -70,6 +70,7 @@ var LibraryGLFW = {
       this.cursorPosFunc = null; // GLFWcursorposfun
       this.cursorEnterFunc = null; // GLFWcursorenterfun
       this.scrollFunc = null; // GLFWscrollfun
+      this.dropFunc = null; // GLFWdropfun
       this.keyFunc = null; // GLFWkeyfun
       this.charFunc = null; // GLFWcharfun
       this.userptr = null;
@@ -80,6 +81,7 @@ var LibraryGLFW = {
       return GLFW.windows[id - 1];
     },
 
+    joystickFunc: null, // GLFWjoystickfun
     errorFunc: null, // GLFWerrorfun
     monitorFunc: null, // GLFWmonitorfun
     active: null, // active window
@@ -343,6 +345,7 @@ var LibraryGLFW = {
 
     onKeyPress: function(event) {
       if (!GLFW.active || !GLFW.active.charFunc) return;
+      if (event.ctrlKey || event.metaKey) return;
 
       // correct unicode charCode is only available with onKeyPress event
       var charCode = event.charCode;
@@ -357,16 +360,17 @@ var LibraryGLFW = {
 #endif
     },
 
-    onKeyChanged: function(event, status) {
+    onKeyChanged: function(keyCode, status) {
       if (!GLFW.active) return;
 
-      var key = GLFW.DOMToGLFWKeyCode(event.keyCode);
+      var key = GLFW.DOMToGLFWKeyCode(keyCode);
       if (key == -1) return;
 
 #if USE_GLFW == 3
       var repeat = status && GLFW.active.keys[key];
 #endif
       GLFW.active.keys[key] = status;
+      GLFW.active.domKeys[keyCode] = status;
       if (!GLFW.active.keyFunc) return;
 
 #if USE_GLFW == 2
@@ -375,12 +379,20 @@ var LibraryGLFW = {
 
 #if USE_GLFW == 3
       if (repeat) status = 2; // GLFW_REPEAT
-      Module['dynCall_viiiii'](GLFW.active.keyFunc, GLFW.active.id, key, event.keyCode, status, GLFW.getModBits(GLFW.active));
+      Module['dynCall_viiiii'](GLFW.active.keyFunc, GLFW.active.id, key, keyCode, status, GLFW.getModBits(GLFW.active));
 #endif
     },
 
+    onGamepadConnected: function(event) {
+      GLFW.refreshJoysticks();
+    },
+
+    onGamepadDisconnected: function(event) {
+      GLFW.refreshJoysticks();
+    },
+
     onKeydown: function(event) {
-      GLFW.onKeyChanged(event, 1); // GLFW_PRESS or GLFW_REPEAT
+      GLFW.onKeyChanged(event.keyCode, 1); // GLFW_PRESS or GLFW_REPEAT
 
       // This logic comes directly from the sdl implementation. We cannot
       // call preventDefault on all keydown events otherwise onKeyPress will
@@ -391,7 +403,17 @@ var LibraryGLFW = {
     },
 
     onKeyup: function(event) {
-      GLFW.onKeyChanged(event, 0); // GLFW_RELEASE
+      GLFW.onKeyChanged(event.keyCode, 0); // GLFW_RELEASE
+    },
+
+    onBlur: function(event) {
+      if (!GLFW.active) return;
+
+      for (var i = 0; i < GLFW.active.domKeys.length; ++i) {
+        if (GLFW.active.domKeys[i]) {
+          GLFW.onKeyChanged(i, 0); // GLFW_RELEASE
+        }
+      }
     },
 
     onMousemove: function(event) {
@@ -628,6 +650,67 @@ var LibraryGLFW = {
       }
     },
 
+    setJoystickCallback: function(cbfun) {
+      GLFW.joystickFunc = cbfun; GLFW.refreshJoysticks();
+    },
+
+    joys: {}, // glfw joystick data
+    lastGamepadState: null,
+    lastGamepadStateFrame: null, // The integer value of Browser.mainLoop.currentFrameNumber of when the last gamepad state was produced.
+
+    refreshJoysticks: function() {
+      // Produce a new Gamepad API sample if we are ticking a new game frame, or if not using emscripten_set_main_loop() at all to drive animation.
+      if (Browser.mainLoop.currentFrameNumber !== GLFW.lastGamepadStateFrame || !Browser.mainLoop.currentFrameNumber) {
+        GLFW.lastGamepadState = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : null);
+        GLFW.lastGamepadStateFrame = Browser.mainLoop.currentFrameNumber;
+
+        for (var joy = 0; joy < GLFW.lastGamepadState.length; ++joy) {
+          var gamepad = GLFW.lastGamepadState[joy];
+
+          if (gamepad) {
+            if (!GLFW.joys[joy]) {
+              console.log('glfw joystick connected:',joy);
+              GLFW.joys[joy] = {
+                id: allocate(intArrayFromString(gamepad.id), 'i8', ALLOC_NORMAL),
+                buttonsCount: gamepad.buttons.length,
+                axesCount: gamepad.axes.length,
+                buttons: allocate(new Array(gamepad.buttons.length), 'i8', ALLOC_NORMAL),
+                axes: allocate(new Array(gamepad.axes.length*4), 'float', ALLOC_NORMAL)
+              };
+
+              if (GLFW.joystickFunc) {
+                Module['dynCall_vii'](GLFW.joystickFunc, joy, 0x00040001); // GLFW_CONNECTED
+              }
+            }
+
+            var data = GLFW.joys[joy];
+
+            for (var i = 0; i < gamepad.buttons.length;  ++i) {
+              setValue(data.buttons + i, gamepad.buttons[i].pressed, 'i8');
+            }
+
+            for (var i = 0; i < gamepad.axes.length; ++i) {
+              setValue(data.axes + i*4, gamepad.axes[i], 'float');
+            }
+          } else {
+            if (GLFW.joys[joy]) {
+              console.log('glfw joystick disconnected',joy);
+
+              if (GLFW.joystickFunc) {
+                Module['dynCall_vii'](GLFW.joystickFunc, joy, 0x00040002); // GLFW_DISCONNECTED
+              }
+
+              _free(GLFW.joys[joy].id);
+              _free(GLFW.joys[joy].buttons);
+              _free(GLFW.joys[joy].axes);
+
+              delete GLFW.joys[joy];
+            }
+          }
+        }
+      }
+    },
+
     setKeyCallback: function(winid, cbfun) {
       var win = GLFW.WindowFromId(winid);
       if (!win) return;
@@ -658,6 +741,69 @@ var LibraryGLFW = {
       win.scrollFunc = cbfun;
     },
 
+    setDropCallback: function(winid, cbfun) {
+      var win = GLFW.WindowFromId(winid);
+      if (!win) return;
+      win.dropFunc = cbfun;
+    },
+
+    onDrop: function(event) {
+      if (!GLFW.active || !GLFW.active.dropFunc) return;
+      if (!event.dataTransfer || !event.dataTransfer.files || event.dataTransfer.files.length == 0) return;
+
+      event.preventDefault();
+
+      var filenames = allocate(new Array(event.dataTransfer.files.length*4), 'i8*', ALLOC_NORMAL);
+      var filenamesArray = [];
+      var count = event.dataTransfer.files.length;
+
+      // Read and save the files to emscripten's FS
+      var written = 0;
+      var drop_dir = '.glfw_dropped_files';
+      FS.createPath('/', drop_dir);
+
+      function save(file) {
+        var path = '/' + drop_dir + '/' + file.name.replace(/\//g, '_');
+        var reader = new FileReader();
+        reader.onloadend = function(e) {
+          if (reader.readyState != 2) { // not DONE
+            ++written;
+            console.log('failed to read dropped file: '+file.name+': '+reader.error);
+            return;
+          }
+
+          var data = e.target.result;
+          FS.writeFile(path, new Uint8Array(data), { encoding: 'binary' });
+          if (++written === count) {
+            Module['dynCall_viii'](GLFW.active.dropFunc, GLFW.active.id, count, filenames);
+
+            for (var i = 0; i < filenamesArray.length; ++i) {
+              _free(filenamesArray[i]);
+            }
+            _free(filenames);
+          }
+        };
+        reader.readAsArrayBuffer(file);
+
+        var filename = allocate(intArrayFromString(path), 'i8', ALLOC_NORMAL);
+        filenamesArray.push(filename);
+        setValue(filenames + i*4, filename, 'i8*');
+      }
+
+      for (var i = 0; i < count; ++i) {
+        save(event.dataTransfer.files[i]);
+      }
+
+      return false;
+    },
+
+    onDragover: function(event) {
+      if (!GLFW.active || !GLFW.active.dropFunc) return;
+
+      event.preventDefault();
+      return false;
+    },
+
     setWindowSizeCallback: function(winid, cbfun) {
       var win = GLFW.WindowFromId(winid);
       if (!win) return;
@@ -941,9 +1087,12 @@ var LibraryGLFW = {
     GLFW.windows = new Array()
     GLFW.active = null;
 
+    window.addEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
+    window.addEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
     window.addEventListener("keydown", GLFW.onKeydown, true);
     window.addEventListener("keypress", GLFW.onKeyPress, true);
     window.addEventListener("keyup", GLFW.onKeyup, true);
+    window.addEventListener("blur", GLFW.onBlur, true);
     Module["canvas"].addEventListener("mousemove", GLFW.onMousemove, true);
     Module["canvas"].addEventListener("mousedown", GLFW.onMouseButtonDown, true);
     Module["canvas"].addEventListener("mouseup", GLFW.onMouseButtonUp, true);
@@ -951,6 +1100,8 @@ var LibraryGLFW = {
     Module["canvas"].addEventListener('mousewheel', GLFW.onMouseWheel, true);
     Module["canvas"].addEventListener('mouseenter', GLFW.onMouseenter, true);
     Module["canvas"].addEventListener('mouseleave', GLFW.onMouseleave, true);
+    Module["canvas"].addEventListener('drop', GLFW.onDrop, true);
+    Module["canvas"].addEventListener('dragover', GLFW.onDragover, true);
 
     Browser.resizeListeners.push(function(width, height) {
        GLFW.onCanvasResize(width, height);
@@ -959,9 +1110,12 @@ var LibraryGLFW = {
   },
 
   glfwTerminate: function() {
+    window.removeEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
+    window.removeEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
     window.removeEventListener("keydown", GLFW.onKeydown, true);
     window.removeEventListener("keypress", GLFW.onKeyPress, true);
     window.removeEventListener("keyup", GLFW.onKeyup, true);
+    window.removeEventListener("blur", GLFW.onBlur, true);
     Module["canvas"].removeEventListener("mousemove", GLFW.onMousemove, true);
     Module["canvas"].removeEventListener("mousedown", GLFW.onMouseButtonDown, true);
     Module["canvas"].removeEventListener("mouseup", GLFW.onMouseButtonUp, true);
@@ -969,6 +1123,10 @@ var LibraryGLFW = {
     Module["canvas"].removeEventListener('mousewheel', GLFW.onMouseWheel, true);
     Module["canvas"].removeEventListener('mouseenter', GLFW.onMouseenter, true);
     Module["canvas"].removeEventListener('mouseleave', GLFW.onMouseleave, true);
+    Module["canvas"].removeEventListener('drop', GLFW.onDrop, true);
+    Module["canvas"].removeEventListener('dragover', GLFW.onDragover, true);
+
+
     Module["canvas"].width = Module["canvas"].height = 1;
     GLFW.windows = null;
     GLFW.active = null;
@@ -1230,6 +1388,17 @@ var LibraryGLFW = {
   glfwGetInputMode: function(winid, mode) {
     var win = GLFW.WindowFromId(winid);
     if (!win) return;
+
+    switch (mode) {
+      case 0x00033001: { // GLFW_CURSOR
+        if (Browser.pointerLock) {
+          win.inputModes[mode] = 0x00034003; // GLFW_CURSOR_DISABLED
+        } else {
+          win.inputModes[mode] = 0x00034001; // GLFW_CURSOR_NORMAL
+        }
+      }
+    }
+
     return win.inputModes[mode];
   },
 
@@ -1280,13 +1449,49 @@ var LibraryGLFW = {
     GLFW.setScrollCallback(winid, cbfun);
   },
 
-  glfwJoystickPresent: function(joy) { throw "glfwJoystickPresent is not implemented."; },
+  glfwJoystickPresent: function(joy) {
+    GLFW.refreshJoysticks();
+
+    return GLFW.joys[joy] !== undefined;
+  },
+
+  glfwGetJoystickAxes: function(joy, count) {
+    GLFW.refreshJoysticks();
+
+    var state = GLFW.joys[joy];
+    if (!state || !state.axes) {
+      setValue(count, 0, 'i32');
+      return;
+    }
+
+    setValue(count, state.axesCount, 'i32');
+    return state.axes;
+  },
+
+  glfwGetJoystickButtons: function(joy, count) {
+    GLFW.refreshJoysticks();
 
-  glfwGetJoystickAxes: function(joy, count) { throw "glfwGetJoystickAxes is not implemented."; },
+    var state = GLFW.joys[joy];
+    if (!state || !state.buttons) {
+      setValue(count, 0, 'i32');
+      return;
+    }
 
-  glfwGetJoystickButtons: function(joy, count) { throw "glfwGetJoystickButtons is not implemented."; },
+    setValue(count, state.buttonsCount, 'i32');
+    return state.buttons;
+  },
 
-  glfwGetJoystickName: function(joy) { throw "glfwGetJoystickName is not implemented."; },
+  glfwGetJoystickName: function(joy) {
+    if (GLFW.joys[joy]) {
+      return GLFW.joys[joy].id;
+    } else {
+      return 0;
+    }
+  },
+
+  glfwSetJoystickCallback: function(cbfun) {
+    GLFW.setJoystickCallback(cbfun);
+  },
 
   glfwSetClipboardString: function(win, string) {},
 
@@ -1302,6 +1507,10 @@ var LibraryGLFW = {
     GLFW.swapBuffers(winid);
   },
 
+  glfwSetDropCallback: function(winid, cbfun) {
+    GLFW.setDropCallback(winid, cbfun);
+  },
+
 #endif // GLFW 3
 
 #if USE_GLFW == 2
